---
layout: post
title: "Release Blog 19.0.0.9"
categories: blog
author_picture: https://avatars3.githubusercontent.com/u/28316667
author_github: https://github.com/tomjenningss
seo-title: Securing Open Liberty apps and microservices with MicroProfile JWT and Social Media login - OpenLiberty.io
seo-description: Take a look at some of the Open Liberty features for securing microservices. Includes an example configuration for securing microservices with MicroProfile JWT and Social Media Login.
blog_description: "Release Blog 19.0.0.9."
---
= Added feature: openidConnectServer-1 on Open Liberty 19.0.0.9 
Tom Jennings <https://github.com/tomjenningss>

OpenID Connect is technology that allows delegation of user authentication to an external security provider. 
Give it a try in link:/about/[Open Liberty] 19.0.0.9.

In Open Liberty 19.0.0.9:

TODO: CHANGE THE LINKS

* <<oidc, OpenID Connect>>
* <<ssl, Oracle SSL properties encryption support>>

---------------------------


If you're curious about what's coming in future Open Liberty releases, take a look at our <<previews,previews in the latest development builds>>. TODO -> UPDATE SENTENCE -> In particular, get an early insight into MicroProfile Reactive Messaging.

== Run your apps using 19.0.0.9

If you're using link:/guides/maven-intro.html[Maven], here are the coordinates:

[source,xml]
----
<dependency>
    <groupId>io.openliberty</groupId>
    <artifactId>openliberty-runtime</artifactId>
    <version>19.0.0.9</version>
    <type>zip</type>
</dependency>
----

Or for link:/guides/gradle-intro.html[Gradle]:

[source,gradle]
----
dependencies {
    libertyRuntime group: 'io.openliberty', name: 'openliberty-runtime', version: '[19.0.0.9,)'
}
----

Or if you're using Docker:

[source]
----
docker pull open-liberty
----

Or take a look at our link:/downloads/[Downloads page].

[link=https://stackoverflow.com/tags/open-liberty]
image::/img/blog/blog_btn_stack.svg[Ask a question on Stack Overflow, align="center"]

[#oidc]
== OpenID Connect Server 

OpenID Connect is a technology that allows delegation of user authentication to an external security provider.

Liberty's OpenID Connect Server feature now includes support for long lived application passwords and application tokens, for use by non browser applications. Users can acquire these and submit them to a non-browser application, which can then use them to access secured resources on servers configured to accept OAuth access tokens from the OpenID Connect server. The user's password is never exposed to the non-browser app, and the tokens can be revoked independently if needed. App-passwords are exchanged repetitively by the non-browser app for short lived access tokens using a standard OAuth ROPC flow, so if an access token is ever compromised, it is not valid for long. App-tokens are long lived access tokens.

Web and REST interfaces for users and administrators are added to administer these tokens.
A new UI for managing client registration is also added.

To give it a go, create a new Liberty server and use this `server.xml`. Comments in server.xml explain the new configuration attributes. This server doesn't have a backing database so is for demo purposes only.

[source,xml]
----
<server>
    <featureManager>      
      <feature>openidConnectServer-1.0</feature>     
    </featureManager>

    <openidConnectProvider id="OP" oauthProviderRef="OAuth" 
        signatureAlgorithm="RS256" keyStoreRef="defaultKeyStore" 
        jwkEnabled="true"
    >
    </openidConnectProvider>
    
    <!-- internalClientID and internalClientSecret match a defined 
         client and are used in creating app-passwords and app-tokens.
         passwordGrantRequiresAppPassword enables the ROPC flow to 
         exchange app-passwords for short-lived access tokens.
         appPasswordLifetime and appTokenLifetime set the lifetime of these tokens.
    --> 
    <oauthProvider id="OAuth" tokenFormat="mpjwt" 
      passwordGrantRequiresAppPassword="true" 
      internalClientId="RP" 
      internalClientSecret="thesecret" 
      appPasswordLifetime="30d"
      >
        <!-- 
         localStore for demo use, a backing database is used instead in production. 
         When localStore is used, all client data and token status is held
         in memory only. 
        --> 
        <localStore>
         
          <!-- appPasswordAllowed and appTokenAllowed allow 
          this client to create app-passwords and app-tokens -->
          <client displayname="RP" enabled="true"
                name="RP" secret="thesecret" 
                scope="openid profile email"
                preAuthorizedScope="openid profile email"
                appPasswordAllowed="true"
                appTokenAllowed="true"
          >                  
                <redirect>https://localhost:19443/oidcclient/redirect/RP</redirect>
          </client>    
        </localStore>
    </oauthProvider>
     
    <oauth-roles>
        <authenticated>
            <special-subject type="ALL_AUTHENTICATED_USERS" />  
        </authenticated> 
         <tokenManager>
           <!-- this user can manage the app-passwords and tokens of other users -->
            <user name="admin" />
        </tokenManager> 
    </oauth-roles>

    <!-- Basic registry for test / development use. -->   
    <basicRegistry id="basic" realm="customRealm">
        <user          
          name="admin"
          password="adminpwd" />
        <user
          name="demouser2"
          password="demopassword2" />
         <group name="users">
             <member name="admin"/>
             <member name="demouser2" />
        </group>
    </basicRegistry>

    <httpEndpoint id="defaultHttpEndpoint" host="*" httpPort="29080" httpsPort="29443" />
    <keyStore id="defaultKeyStore" password="keyspass" />  

</server>
----

Now users can request and manage their own tokens at
https://host:port/oidc/endpoint/(provider id)/personalTokenManagement. Token admins can administer the tokens of other users at https://host:port/oidc/endpoint/(provider id)/usersTokenManagement. Servers using a database (not this demo) can now manage client registration at https://host:port/oidc/endpoint/(provider id)/clientManagement.

To try it out, start the server and log in as admin, adminpwd at
https://localhost:29443/oidc/endpoint/OP/personalTokenManagement

Your app-passwords and tokens might look something like this:

https://user-images.githubusercontent.com/26486297/63465347-a9517500-c426-11e9-8a4a-b7356072617d.png


These tokens can be submitted to non-browser applications, which can in turn use them when accessing secured resources on servers configured to accept access tokens from the OpenID Connect server.

* Guide: link:<possible link>

[]
== New title 

- - - 
//This displays a hard rule / line across the page

[#previews]
== Previews of early implementations available in development builds

You can now also try out early implementations of some new capabilities in the link:/downloads/#development_builds[latest Open Liberty development builds]:


//
* <<mpreactive,MicroProfile Reactive Messaging>>
* <<testingdb,Testing database connections in Liberty apps with REST APIs>>


These early implementations are not available in 19.0.0.8 but you can try them out in our daily Docker image by running `docker pull openliberty/daily`. Let us know what you think!

//

[#mpreactive]
=== Reactive messaging in microservices (MicroProfile Reactive Messaging)
An application using reactive messaging is composed of CDI beans consuming, producing, and processing messages passing along reactive streams. These messages can be internal to the application or can be sent and received via different message brokers.

Reactive Messaging provides a very easy to use way to send, receive, and process messages. With MicroProfile Reactive Messaging, you can annotate application beans' methods to have messages on a particular channel (@Incoming, @Outgoing, or both) and Liberty drives those methods appropriately as reactive streams publishers, subscribers, or processors.

To enable the feature include it in your `server.xml` feature list:

[source,xml]
----
<featureManager>
  <feature>mpReactiveMessaging-1.0</feature>
  ...
</featureManager>
----

With this feature in the OpenLiberty runtime, an application CDI bean can have one of its methods annotated as being message driven. In the example below, the method processes messages from the "greetings" channel:

[source,java]
----
@Incoming("greetings")
publicCompletionStage <Void> consume(Message<String> greeting ){
   return greeting.ack();
}
----

A channel represents a stream of messages of a given type and, usually, the same topic. Channels can operate locally within the process or use message brokers to send messages between services.

For example, with no code changes we could change the consume method above to subscribe to messages from the Kafka greetings topic using a Kafka connector like so:

[source,text]
----
mp.messaging.incoming.greetings.connector=io.openliberty.kafka
----

The `io.openliberty.kafka` connector operates according to the reactive messaging specification. For example the `consume` method above is, by default, set to consume messages from a Kafka topic queue. Further Kafka client properties can be set for the channel by setting properties that are picked up by the MicroProfile Config specification. For example, System properties via OpenLiberty's `bootstrap.properties` file or environment variables from OpenLiberty's `server.env` file. As per the reactive messaging specification the following configuration properties are passed
to the Kafka client:

[source,text]
----
mp.messaging.incoming.greetings.[PROPERTY-NAME]=value1
mp.messaging.connector.io.openliberty.kafka.[PROPERTY-NAME]=value2
----

These are passed to the Kafka Consumer factory method as:

[source,text]
----
PROPERTY-NAME=value
----

So, for example, a full set of properties to access IBM Public Cloud Event Streams could look like:

[source,text]
----
mp.messaging.connector.io.openliberty.kafka.bootstrap.servers=broker-1-eventstreams.cloud.ibm.com:9093,broker-2-eventstreams.cloud.ibm.com:9093
mp.messaging.connector.io.openliberty.kafka.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="token" password="my-apikey";
mp.messaging.connector.io.openliberty.kafka.sasl.mechanism=PLAIN
mp.messaging.connector.io.openliberty.kafka.security.protocol=SASL_SSL
mp.messaging.connector.io.openliberty.kafka.ssl.protocol=TLSv1.2
----

When using Kafka-based channels, Open Liberty Reactive Messaging 1.0 loads the Kafka client classes using the application classloader. If you are using the `io.openliberty.kafka` connector to
read or write Kafka messages, include in your application a Kafka client API jar that is compatible with your Kafka server. For example, the `/WEB-INF/lib/` folder would be a suitable place to place a Kafka client JAR when building the application's `.war` file.

This is an early release of the Open Liberty Reactive Messaging Kafka connector. We will look to provide more support for sensible defaults and cloud binding information such as Cloud Foundry's `VCAP_SERVICES` environment variable in the 1.0 release.



Find out more in the link:https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/microprofile-reactive-messaging-spec.pdf[MicroProfile Reactive Messaging spec].


//

[#testingdb]
=== Testing database connections in Liberty apps with REST APIs

How many times have you had to write a server-side test that gets a connection just to check if your configuration is valid and your app can connect to your database? Now by utilizing the REST API provided by the configValidator-1.0 beta feature, you can validate supported elements of your configuration via REST endpoints.

To enable these REST endpoints, add the configValidator-1.0 beta feature to any server using JDBC, JCA, or JMS technologies. For more information checkout this link:/blog/2019/05/24/testing-database-connections-REST-APIs.html[blog post].

[source,xml]
----
<featureManager>
    <feature>configValidator-1.0</feature>
</featureManager>
----
//