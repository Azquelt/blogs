---
layout: post
title: "191000"
categories: blog
author_picture: https://avatars3.githubusercontent.com/tomjenningss
author_github: https://github.com/tomjenningss
seo-title: First initial blog post for 191000 - OpenLiberty.io
seo-description: First initial blog post for 191000r.
blog_description: "First initial blog post for 191000."
---
= 19.10.0.0 Blog release
Tom Jennings <https://github.com/tomjenningss>

<Introduction>

Give it a try in link:/about/[Open Liberty] 19.10.0.0

In Open Liberty 19.10.0.0:

* <<link, link >>



//If you're curious about what's coming in future Open Liberty releases, take a look at our <<previews,previews in the latest development builds>>. In particular, get an early insight into MicroProfile Reactive Messaging. [None in 19009]

[#run]
== Run your apps using 19.10.0.0

If you're using link:/guides/maven-intro.html[Maven], here are the coordinates:

[source,xml]
----
<dependency>
    <groupId>io.openliberty</groupId>
    <artifactId>openliberty-runtime</artifactId>
    <version>19.10.0.0</version>
    <type>zip</type>
</dependency>
----

Or for link:/guides/gradle-intro.html[Gradle]:

[source,gradle]
----
dependencies {
    libertyRuntime group: 'io.openliberty', name: 'openliberty-runtime', version: '[19.10.0.0,)'
}
----

Or if you're using Docker:

[source]
----
docker pull open-liberty
----

Or take a look at our link:/downloads/[Downloads page].

[link=https://stackoverflow.com/tags/open-liberty]
image::/img/blog/blog_btn_stack.svg[Ask a question on Stack Overflow, align="center"]


== Previews of early implementations available in development builds

* <<JMOT,Jaeger for Microprofile OpenTracing>>

== Jaeger for MicroProfile OpenTracing (jaeger-1.0)

Open Liberty can use Jaeger as a tracing backend for MicroProfile OpenTracing. OpenLiberty has the support of MicroProfile OpenTracing. A sample tracer was provided at https://github.com/WASdev/sample.opentracing.zipkintracer for using Zipkin as a tracing backend. With the introduction of jaeger-1.0, developers can also use Jaeger as a tracing backend.

You will need to download the Jaeger client version 0.34.0 library and its dependencies from link:/https://mvnrepository.com/artifact/io.jaegertracing/jaeger-client/0.34.0[Maven repository.]

To enable the feature include it in your [server.xml] feature list:

[source, xml]

Add <feature>jaeger-1.0</feature> under <featureManager> section

Add the following snippet:

[source, xml]

<library id="jaegerLib" apiTypeVisibility="api,ibm-api,spec,stable,third-party" >
        <file name="<path>/jaegerLib_0.34/gson-2.8.2.jar" />
        <file name="<path>/jaegerLib_0.34/jaeger-client-0.34.0.jar" />
        <file name="<path>/jaegerLib_0.34/jaeger-core-0.34.0.jar" />
        <file name="<path>/jaegerLib_0.34/jaeger-thrift-0.34.0.jar" />
        <file name="<path>/jaegerLib_0.34/jaeger-tracerresolver-0.34.0.jar" />
        <file name="<path>/jaegerLib_0.34/libthrift-0.12.0.jar" />
        <file name="<path>/jaegerLib_0.34/slf4j-api-1.7.25.jar" />
        <file name="<path>/jaegerLib_0.34/slf4j-jdk14-1.7.25.jar" />
        <file name="<path>/jaegerLib_0.34/opentracing-util-0.31.0.jar" />
        <file name="<path>/jaegerLib_0.34/opentracing-noop-0.31.0.jar" />
    </library>

Define your application:

[source, xml]

 <webApplication location="yourapp.war" contextRoot="/yourapp">
        <!-- enable visibility to third party apis -->
        <classloader commonLibraryRef="jaegerLib"
            apiTypeVisibility="api,ibm-api,spec,stable,third-party" />
    </webApplication>

To find out more about this fantastic technology:

Jaeger settings can be set using link:/https://github.com/jaegertracing/jaeger-client-java/blob/10c641f8df6316f1eac4d5b1715513275bcd724e/jaeger-core/README.md[environment variables]

For the `JAEGER_PASSWORD`, the password can be encoded using the securityUtility command

Depending on Jaeger's sampling settings `JAEGER_SAMPLER_TYPE` and `JAEGER_SAMPLER_PARAM`, Jaeger may not report every spans created by the applications.


== MicroProfile Metrics 2.1

Metrics 2.1 is a new feature to support MicroProfile Metrics 2.1 Specification. MicroProfile Metrics 2.1 enables developers to instrument metrics in their (microservice) applications for easy monitoring by their operations team.


Previously, the Gauge metric was intended to sample numerical values only, but users could sample non-numeric values (such as String). MicroProfile Metrics 2.1 can only sample numbers now.

Previously, the MetadataBuilder API had reusable() and notReusable() method to set the reusable field to true or false. The MetadataBuilder API has been changed to include a new setter method for the reusable attribute. This change is so the MetadataBuilder follows the builder pattern.



== MicroProfile Health Check 2.1


MicroProfile Health check has been updated with a new feature to support MicroProfile Health Check 2.1 specification.

Health Check 2.1 enables you to provide your own health check procedures to be invoked by Liberty, to verify the health of your microservice.

In mpHealth-2.1 feature for OpenLiberty, you can now use convenient and simpler methods from standard Java APIs, to construct UP/DOWN named health check responses, in your applications, such as

`HealthCheckResponse.up("myCheck");`

In previous versions, to define a simple successful/failed named health check response, the application level code is always expected to use several static methods together from the HealthCheckResponse API, to retrieve a HealthCheckResponseBuilder used to construct a HealthCheck response.

`HealthCheckResponse.named(“myCheck”).up().build();`

To make it work include the following in the `server.xml` file:

[source, xml]
<feature>mpHealth-2.1</feature>

Applications are expected to provide health check procedures, by implementing the HealthCheck interface with the @Liveness or @readiness annotations, which will be used by Liberty to verify the Liveness or Readiness of the application, respectively. Add the logic of your health check in the call() method, and return the HealthCheckResponse object, by constructing using the simple up()/down() methods from the API. To view the status of each health check, access the either the `http://<hostname>:<port>/health/live` or `http://<hostname>:<port>/health/ready` endpoints.

[source, xml]

**Liveness Check**
@Liveness
@ApplicationScoped
public class AppLiveCheck implements HealthCheck {
...
    @Override
     public HealthCheckResponse call() {
       ...
       HealthCheckResponse.up("myCheck");
       ...
     }
}

== Get Liberty 19.10.0.0 now

Available through <<run,Maven, Gradle, Docker, and as a downloadable archive>>.
