---
layout: post
title: TODO on Open Liberty 19.0.0.5
categories: blog
author_picture: https://avatars3.githubusercontent.com/u/3322532
author_github: https://github.com/lauracowen
seo-title: TODO on Open Liberty 19.0.0.5 - OpenLiberty.io.
seo-description: TODO
blog_description: "TODO"
---
= TODO on Open Liberty 19.0.0.5
Laura Cowen <https://github.com/lauracowen>

TODO intro

* <<java11,Support for OpenJDK 11 with Hotspot>>
* Previews of early implementations available in the latest development builds
** <<postgresql,Support for PostgreSQL relational database>>
** <<testingdb,Testing database connections in Liberty apps wtih REST APIs>>
** <<mpconcurrency,MicroProfile Context Propagation 1.0 (formerly MicroProfile Concurrency 1.0)>>


If you're using link:/guides/maven-intro.html[Maven], here are the coordinates:

[source,xml]
----
<dependency>
    <groupId>io.openliberty</groupId>
    <artifactId>openliberty-runtime</artifactId>
    <version>19.0.0.5</version>
    <type>zip</type>
</dependency>
----

Or for link:/guides/gradle-intro.html[Gradle]:

[source,json]
----
dependencies {
    libertyRuntime group: 'io.openliberty', name: 'openliberty-runtime', version: '[19.0.0.5,)'
}
----

Or if you're using Docker:

[source]
----
docker pull open-liberty
----

Or take a look at our link:/downloads/[Downloads page].

[link=https://stackoverflow.com/tags/open-liberty]
image::/img/blog/blog_btn_stack.svg[Ask a question on Stack Overflow, align="center"]


//


[#java11]
== Support for OpenJDK 11 with Hotspot

Support for TLSv1.3 has been turned on for OpenJDK 11 w/ Hotspot, meaning that OpenLiberty will now work with both of the main JVMs (OpenJ9 and Hotspot).


See also: link:https://openliberty.io/docs/ref/general/#java-se.html[Java SE support on Open Liberty]


//



[#previews]
== Previews of early implementations available in beta status

You can now also try out early implementations of some new capabilities in the link:/downloads/#development_builds[latest Open Liberty development builds]:

** <<postgresql,Support for PostgreSQL relational database>>
** <<testingdb,Testing database connections in Liberty apps wtih REST APIs>>
*  <<mpconcurrency,MicroProfile Context Propagation 1.0>>


This early implementation is not available in 19.0.0.5 but you can try it out by downloading the link:/downloads/#development_builds[latest Open Liberty development build]. Let us know what you think!




[#postgresql]
=== Support for PostgreSQL relational database

PostgreSQL is a very popular open source relational database that has a wide amount of adoption in the community. Now there is a first-class configuration support for using it with Open Liberty.

To use PostgreSQL with Open Liberty, first make sure one of the JDBC features is enabled:

[source,xml]
----
<featureManager>
    <feature>jdbc-4.2</feature>
    <feature>jndi-1.0</feature> <!-- Required only if JNDI is desired to look up resources -->
</featureManager>
----

Then, configure a data source as follows:

[source,xml]
----
<dataSource jndiName="jdbc/postgresql">
  <jdbcDriver libraryRef="PostgresLib" />
  <properties.postgresql serverName="localhost" portNumber="5432" databaseName="SAMPLEDB" 
                         user="bob" password="secret"/>
</dataSource>

<library id="PostgresLib">
    <fileset dir="${server.config.dir}/jdbc"/>
</library>
----

Get the JDBC driver for PostgreSQL https://mvnrepository.com/artifact/org.postgresql/postgresql[from Maven Central].

Get the Postgres Docker images https://hub.docker.com/_/postgres[from DockerHub].

For more about PostgreSQL, see https://www.postgresql.org/[PostgreSQL website].

//

[#testingdb]
=== Testing database connections in Liberty apps wtih REST APIs

TODO


//

[#mpconcurrency]
=== MicroProfile Context Propagation 1.0 (formerly MicroProfile Concurrency 1.0)

MicroProfile Context Propagation (formerly MicroProfile Concurrency) allows you to create completion stages that run with predictable thread context regardless of which thread the completion stage action ends up running on.

MicroProfile Context Propagation provides completion stages that run with predictable thread context that also benefit from being backed by the automatically-tuned Liberty global thread pool. Configuration of concurrency constraints and context propagation is possible programmatically with fluent builder API where defaults can be established using MicroProfile Config.

To enable the MicroProfile Context Propagation 1.0 feature in your `server.xml`:

[source,xml]
----
<featureManager>
    <feature>mpContextPropagation-1.0</feature>
    <feature>cdi-2.0</feature> <!-- used in example -->
    <feature>jndi-1.0</feature> <!-- used in example -->
    ... other features
</featureManager>
----


Example usage of programmatic builders:

[source,java]
----
ManagedExecutor executor = ManagedExecutor.builder()
    .maxAsync(5)
    .propagated(ThreadContext.APPLICATION, ThreadContext.SECURITY)
    .build();

CompletableFuture<Integer> stage1 = executor.newIncompleteFuture();
stage1.thenApply(function1).thenAccept(value -> {
    try {
        // access resource reference in application's java:comp namespace,
        DataSource ds = InitialContext.doLookup("java:comp/env/jdbc/ds1");
        ...
    } catch (Exception x) {
        throw new CompletionException(x);
    }
};
...
stage1.complete(result);
----


Example usage in a CDI bean:

[source,java]
----
// CDI qualifier which is used to identify the executor instance
@Qualifier
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })
public @interface AppContext {}

// Example producer field, defined in a CDI bean,
@Produces @ApplicationScoped @AppContext
ManagedExecutor appContextExecutor = ManagedExecutor.builder()
    .propagated(ThreadContext.APPLICATION)
    .build();

// Example disposer method, also defined in the CDI bean,
void disposeExecutor(@Disposes @AppContext exec) {
    exec.shutdownNow();
}

// Example injection point, defined in a CDI bean,
@Inject @AppContext
ManagedExecutor executor;

...

CompletableFuture<Integer> stage = executor
    .supplyAsync(supplier1)
    .thenApply(function1)
    .thenApplyAsync(value -> {
        try {
            // access resource reference in application's java:comp namespace,
            DataSource ds = InitialContext.doLookup("java:comp/env/jdbc/ds1");
            ...
            return result;
        } catch (Exception x) {
            throw new CompletionException(x);
        }
    });
----


For more information:

* link:/blog/2019/03/01/microprofile-concurrency.html[Nathan's blog post on MicroProfile Context Propagation 1.0]
* https://github.com/eclipse/microprofile-concurrency[MicroProfile Context Propagation 1.0 spec]
* https://github.com/eclipse/microprofile-context-propagation/releases[Information about the latest release candidate] (including the specification, the Javadoc API, and Maven coordinates for the spec jar)
