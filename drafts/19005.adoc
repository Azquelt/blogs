---
layout: post
title: TODO on Open Liberty 19.0.0.5
categories: blog
author_picture: https://avatars3.githubusercontent.com/u/3322532
author_github: https://github.com/lauracowen
seo-title: TODO on Open Liberty 19.0.0.5 - OpenLiberty.io.
seo-description: TODO
blog_description: "TODO"
---
= TODO on Open Liberty 19.0.0.5
Laura Cowen <https://github.com/lauracowen>

TODO

* <<mpreactive,Reactive programming in microservices (MicroProfile Reactive Streams Operators 1.0)>>


* Previews of early implementations available in the latest development builds
** <<mpconcurrency,MicroProfile Context Propagation 1.0 (formerly MicroProfile Concurrency 1.0)>>


If you're using link:/guides/maven-intro.html[Maven], here are the coordinates:

[source,xml]
----
<dependency>
    <groupId>io.openliberty</groupId>
    <artifactId>openliberty-runtime</artifactId>
    <version>19.0.0.5</version>
    <type>zip</type>
</dependency>
----

Or for link:/guides/gradle-intro.html[Gradle]:

[source,json]
----
dependencies {
    libertyRuntime group: 'io.openliberty', name: 'openliberty-runtime', version: '[19.0.0.5,)'
}
----

Or if you're using Docker:

[source]
----
docker pull open-liberty
----

Or take a look at our link:/downloads/[Downloads page].

[link=https://stackoverflow.com/tags/open-liberty]
image::/img/blog/blog_btn_stack.svg[Ask a question on Stack Overflow, align="center"]


//

[#mpreactive]
== Reactive programming in microservices (MicroProfile Reactive Streams Operators 1.0)
TODO

To enable the MicroProfile Reactive Streams Operators feature in your `server.xml`:

[source,xml]
----
<featureManager>
        <feature>mpReactiveStreams-1.0</feature>
</featureManager>
----



See also: link:https://github.com/eclipse/microprofile-reactive-streams-operators/releases/download/1.0/microprofile-reactive-streams-operators-spec-1.0.pdf[MicroProfile Reactive Streams Operators specification]




//



[#previews]
== Previews of early implementations available in the latest development builds

You can now also try out early implementations of some new capabilities in the link:/downloads/#development_builds[latest Open Liberty development builds]:

*  <<mpconcurrency,MicroProfile Context Propagation 1.0>>


This early implementation is not available in 19.0.0.5 but you can try it out by downloading the link:/downloads/#development_builds[latest Open Liberty development build]. Let us know what you think!


[#mpconcurrency]
=== MicroProfile Context Propagation 1.0 (formerly MicroProfile Concurrency 1.0)

MicroProfile Context Propagation (formerly MicroProfile Concurrency) allows you to create completion stages that run with predictable thread context regardless of which thread the completion stage action ends up running on.

MicroProfile Context Propagation provides completion stages that run with predictable thread context that also benefit from being backed by the automatically-tuned Liberty global thread pool. Configuration of concurrency constraints and context propagation is possible programmatically with fluent builder API where defaults can be established using MicroProfile Config.

To enable the MicroProfile Context Propagation 1.0 feature in your `server.xml`:

[source,xml]
----
<featureManager>
    <feature>mpContextPropagation-1.0</feature>
    <feature>cdi-2.0</feature> <!-- used in example -->
    <feature>jndi-1.0</feature> <!-- used in example -->
    ... other features
</featureManager>
----


Example usage of programmatic builders:

[source,java]
----
ManagedExecutor executor = ManagedExecutor.builder()
    .maxAsync(5)
    .propagated(ThreadContext.APPLICATION, ThreadContext.SECURITY)
    .build();

CompletableFuture<Integer> stage1 = executor.newIncompleteFuture();
stage1.thenApply(function1).thenAccept(value -> {
    try {
        // access resource reference in application's java:comp namespace,
        DataSource ds = InitialContext.doLookup("java:comp/env/jdbc/ds1");
        ...
    } catch (Exception x) {
        throw new CompletionException(x);
    }
};
...
stage1.complete(result);
----


Example usage in a CDI bean:

[source,java]
----
// CDI qualifier which is used to identify the executor instance
@Qualifier
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })
public @interface AppContext {}

// Example producer field, defined in a CDI bean,
@Produces @ApplicationScoped @AppContext
ManagedExecutor appContextExecutor = ManagedExecutor.builder()
    .propagated(ThreadContext.APPLICATION)
    .build();

// Example disposer method, also defined in the CDI bean,
void disposeExecutor(@Disposes @AppContext exec) {
    exec.shutdownNow();
}

// Example injection point, defined in a CDI bean,
@Inject @AppContext
ManagedExecutor executor;

...

CompletableFuture<Integer> stage = executor
    .supplyAsync(supplier1)
    .thenApply(function1)
    .thenApplyAsync(value -> {
        try {
            // access resource reference in application's java:comp namespace,
            DataSource ds = InitialContext.doLookup("java:comp/env/jdbc/ds1");
            ...
            return result;
        } catch (Exception x) {
            throw new CompletionException(x);
        }
    });
----


For more information:

* link:/blog/2019/03/01/microprofile-concurrency.html[Nathan's blog post on MicroProfile Context Propagation 1.0]
* https://github.com/eclipse/microprofile-concurrency[MicroProfile Context Propagation 1.0 spec]
* https://github.com/eclipse/microprofile-context-propagation/releases[Information about the latest release candidate] (including the specification, the Javadoc API, and Maven coordinates for the spec jar)
