---
layout: post
title: MicroProfile 3.0 with improved developer experience on Open Liberty 19.0.0.7
categories: blog
author_picture: https://avatars1.githubusercontent.com/u/52958137
author_github: https://github.com/yasmin-aumeeruddy
seo-title: MicroProfile 3.0 with improved developer experience on Open Liberty 19.0.0.7 - OpenLiberty.io.
seo-description: MicroProfile 3.0 provides improvements to the developer experience of the Rest Client, Health Check, and Metrics features. Open Liberty also now supports the PostgreSQL relational database.
blog_description: "MicroProfile 3.0 provides improvements to the developer experience of the Rest Client, Health Check, and Metrics features. Open Liberty also now supports the PostgreSQL relational database."
---
= MicroProfile Context Propogation on Open Liberty 19.0.0.8
Yasmin Aumeeruddy <https://github.com/yasmin-aumeeruddy>

 TO DOOOOOO!!!!!!
 
 Give it a try in link:/about/[Open Liberty] 19.0.0.8.

In Open Liberty 19.0.0.8:

* <<mcp1,MicroProfile Context Propagation 1.0>>
* <<ocs,OpenID Connect Server>>
* <<int, IBM WebSphere Open Liberty Introspection>>
** <<over, The Overlay Cache Introspctor>>
** <<zip, The Zip Cache Introspector>>

If you're curious about what's coming in future Open Liberty releases, take a look at our <<previews,previews in the latest development builds>>. In particular, get an early insight into MicroProfile Reactive Messaging.

== Run your apps using 19.0.0.8

If you're using link:/guides/maven-intro.html[Maven], here are the coordinates:

[source,xml]
----
<dependency>
    <groupId>io.openliberty</groupId>
    <artifactId>openliberty-runtime</artifactId>
    <version>19.0.0.8</version>
    <type>zip</type>
</dependency>
----

Or for link:/guides/gradle-intro.html[Gradle]:

[source,gradle]
----
dependencies {
    libertyRuntime group: 'io.openliberty', name: 'openliberty-runtime', version: '[19.0.0.8,)'
}
----

Or if you're using Docker:

[source]
----
docker pull open-liberty
----

Or take a look at our link:/downloads/[Downloads page].

[link=https://stackoverflow.com/tags/open-liberty]
image::/img/blog/blog_btn_stack.svg[Ask a question on Stack Overflow, align="center"]


[#mcp1]
== MicroProfile Context Propagation 1.0

MicroProfile Context Propagation allows you to create pipelines of dependent stages that run with predictable thread context regardless of which thread the completion stage action ends up running on.

MicroProfile Context Propagation provides completion stages that run with predictable thread context and also benefit from being backed by the automatically-tuned Liberty global thread pool. Configuration of concurrency constraints and context propagation is possible programmatically with a fluent builder pattern where configuration defaults can be specified via MicroProfile Config.

Example in server.xml:
[source,xml]
----
  <featureManager>
    <feature>mpContextPropagation-1.0</feature>
    <feature>cdi-2.0</feature> <!-- used in example -->
    <feature>jndi-1.0</feature> <!-- used in example -->
    ... other features
  </featureManager>
----

Example usable of programmatic builders:
[source,java]

----
import org.eclipse.microprofile.context.ManagedExecutor;
import org.eclipse.microprofile.context.ThreadContext;
...

ManagedExecutor executor = ManagedExecutor.builder()
    .maxAsync(5)
    .propagated(ThreadContext.APPLICATION, ThreadContext.SECURITY)
    .build();

CompletableFuture<Integer> stage1 = executor.newIncompleteFuture();
stage1.thenApply(function1).thenAccept(value -> {
    try {
        // access resource reference in application's java:comp namespace,
        DataSource ds = InitialContext.doLookup("java:comp/env/jdbc/ds1");
        ...
    } catch (Exception x) {
        throw new CompletionException(x);
    }
};
...
stage1.complete(result);

...
// Shut down managed executor once the application no longer needs it
executor.shutdown();

----

Example usage in a CDI bean:
[source,java]
----
// CDI qualifier which is used to identify the executor instance
@Qualifier
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })
public @interface AppContext {}

// Example producer field, defined in a CDI bean,
@Produces @ApplicationScoped @AppContext
ManagedExecutor appContextExecutor = ManagedExecutor.builder()
    .propagated(ThreadContext.APPLICATION)
    .build();

// Example disposer method, also defined in the CDI bean,
void disposeExecutor(@Disposes @AppContext exec) {
    exec.shutdownNow();
}

// Example injection point, defined in a CDI bean,
@Inject @AppContext
ManagedExecutor executor;

...

CompletableFuture<Integer> stage = executor
    .supplyAsync(supplier1)
    .thenApply(function1)
    .thenApplyAsync(value -> {
        try {
            // access resource reference in application's java:comp namespace,
            DataSource ds = InitialContext.doLookup("java:comp/env/jdbc/ds1");
            ...
            return result;
        } catch (Exception x) {
            throw new CompletionException(x);
        }
    });
----
For more information:

* link:https://openliberty.io/docs/ref/microprofile/3.0/#package=org/eclipse/microprofile/context/package-frame.html&class=org/eclipse/microprofile/context/package-summary.html[JavaDoc API]
* link:https://github.com/eclipse/microprofile-context-propagation/releases/tag/1.0[Spec binaries and Maven coordinates]
* https://github.com/eclipse/microprofile-context-propagation/releases[Context Propagation 1.0 specification]

[#ocs]
== OpenID Connect Server

OpenID Connect is a technology that allows delegation of user authentication to an external security provider.

Liberty's OpenID Connect Server feature now includes support for long lived application passwords and application tokens, for use by non browser applications. Users can acquire these and submit them to a non-browser application, which can then use them to access secured resources on servers configured to accept OAuth access tokens from the OpenID Connect server. The user's password is never exposed to the non-browser app, and the tokens can be revoked independently if needed. App-passwords are exchanged repetitively by the non-browser app for short lived access tokens using a standard OAuth ROPC flow, so if an access token is ever compromised, it is not valid for long. App-tokens are long lived access tokens.

Web and REST interfaces for users and administrators are added to administer these tokens.

Create a new Liberty server and use this server.xml. Comments in server.xml explain the new configuration attributes. This server doesn't have a backing database so is for demo purposes only.

Example in xml: 
[source,xml]
----
<server>
    <featureManager>      
      <feature>openidConnectServer-1.0</feature>     
    </featureManager>

    <openidConnectProvider id="OP" oauthProviderRef="OAuth" 
        signatureAlgorithm="RS256" keyStoreRef="defaultKeyStore" 
        jwkEnabled="true"
    >
    </openidConnectProvider>
    
    <!-- internalClientID and internalClientSecret match a defined 
         client and are used in creating app-passwords and app-tokens.
         passwordGrantRequiresAppPassword enables the ROPC flow to 
         exchange app-passwords for short-lived access tokens.
         appPasswordLifetime and appTokenLifetime set the lifetime of these tokens.
    --> 
    <oauthProvider id="OAuth" tokenFormat="mpjwt" 
      passwordGrantRequiresAppPassword="true" 
      internalClientId="RP" 
      internalClientSecret="thesecret" 
      appPasswordLifetime="30d"
      >
        <!-- 
         localStore for demo use, a backing database is used instead in production. 
         When localStore is used, all client data and token status is held
         in memory only. 
        --> 
        <localStore>
         
          <!-- appPasswordAllowed and appTokenAllowed allow 
          this client to create app-passwords and app-tokens -->
          <client displayname="RP" enabled="true"
                name="RP" secret="thesecret" 
                scope="openid profile email"
                preAuthorizedScope="openid profile email"
                appPasswordAllowed="true"
                appTokenAllowed="true"
          >                  
                <redirect>https://localhost:19443/oidcclient/redirect/RP</redirect>
          </client>    
        </localStore>
    </oauthProvider>
     
    <oauth-roles>
        <authenticated>
            <special-subject type="ALL_AUTHENTICATED_USERS" />  
        </authenticated> 
         <tokenManager>
           <!-- this user can manage the app-passwords and tokens of other users -->
            <user name="admin" />
        </tokenManager> 
    </oauth-roles>

    <!-- Basic registry for test / development use. -->   
    <basicRegistry id="basic" realm="customRealm">
        <user          
          name="admin"
          password="adminpwd" />
        <user
          name="demouser2"
          password="demopassword2" />
         <group name="users">
             <member name="admin"/>
             <member name="demouser2" />
        </group>
    </basicRegistry>

    <httpEndpoint id="defaultHttpEndpoint" host="*" httpPort="29080" httpsPort="29443" />
    <keyStore id="defaultKeyStore" password="keyspass" />  

</server>
----


Now users can request and manage their own tokens at
`https://host:port/(provider id)/personalTokenManagement`. Token admins can administer the tokens of other users at `https://host:port/(provider id)/usersTokenManagement.`

To try it out, start the server and log in as admin, adminpwd at
`https://localhost:29443/oidc/endpoint/OP/personalTokenManagement`

These tokens can be submitted to non-browser applications, which can in turn use them when accessing secured resources on servers configured to accept access tokens from the OpenID Connect server.

[#int]
== IBM WebSphere Open Liberty Introspection: 
 
IBM WebSphere Open Liberty version 19.0.0.8 adds new introspectors called the Overlay Cache Introspector and the Zip Cache Introspector.

[#over]
=== The Overlay Cache Introspector

The new overlay cache introspector is used to display the active root containers and to display the particular data which has been associated with each container. The viewing archive activity is useful for these purposes:

1. To see what root containers are active within the Open Liberty process.

2. To see the on-disk locations of each of the containers.

3. To obtain a better understanding of typical data which is generated by Open Liberty when starting an application module.

Open Liberty manages application content by creating an "Overlay container" for each of the root locations of the application.  An "Overlay Cache" is associated with each of the root containers.

The associated overlay cache is a two layer dictionary which is used to associate data with the container.  Keys for the first tier are relative paths while keys for the second tier are type names. The overlay cache is used as a mechanism to simplify sharing application related data within the Liberty Application Server.  Sharing a single overlay container replaces sharing many different data items.

The overlay cache introspector runs automatically when using the server dump command and use of the server dump command requires a running Open Liberty server. The overlay container introspector output is written to the standard server dump archive as entry to "OverlayContainerIntrospector.txt".

To create the output, use the following commands:
[source]
----
>> server start <serverName>
>> Starting server <serverName>
>> Server <serverName> started.

>> server dump <serverName>
>> Dumping server <serverName>
>> Server <serverName> dump complete in <serverHome>\<serverName>.dump-<timestamp>.zip.

----

Each use of the server dump command creates a server dump zip file which has a name based on the server name and which includes a timestamp in the name.

The overlay cache introspector output has three sections.

1. Title and Timestamp
2. Listing of Overlay Containers
3. Cache Data for Each Overlay Container 


[#zip]
=== The Zip Cache Introspctor

The new zip cache introspector is used primarily to obtain a view of archive activity within an Open Liberty server process. The viewing archive activity is useful for a number of purposes:

1. To understand the basic flow of archive file activity within a Libery server.

2. To detect exceptional archive activity, for example, a pattern of frequent opens and closes of archives, or, when an extremely large number of archives are being opened.

3. To tell if application archives are held open by the Open Liberty process.  This is useful for cases where dynamic updates to application files are blocked because the files are locked.

4. To verify the health of the zip cache layer.  For example, to make sure the zip reaper thread (see below) is running and has been closing zip files at scheduled times.

5. To diagnose the effectiveness of particular zip cache settings.

The Zip Cache introspector is run automatically when using the server dump command and use of the server dump command requires a running Open Liberty server:

Introspector output is written to the standard server dump archive as entry to "ZipCachingIntrospector.txt".

Use the following commands to create the output:
[source]
----
>> server start <serverName>
>> Starting server <serverName>
>> Server <serverName> started.

>> server dump <serverName>
>> Dumping server <serverName>
>> Server <serverName> dump complete in <serverHome>\<serverName>.dump-<timestamp>.zip.
----
Each use of the server dump command creates a server dump zip file which has a name based on the server name and which includes a timestamp in the name.

The zip cache introspector output contains the following five sections:

1. Title and time stamp
2. List of properties used to configure the zip caching layer
3. List of active and recently used zip file handles
4. Top level state of the zip file cache layer
5. Data for all managed zip files
* https://github.com/eclipse/microprofile-context-propagation/releases[Context Propagation 1.0 specification]

