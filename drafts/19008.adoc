---
layout: post
title: MicroProfile 3.0 with improved developer experience on Open Liberty 19.0.0.8
categories: blog
author_picture: https://avatars1.githubusercontent.com/u/52958137
author_github: https://github.com/yasmin-aumeeruddy
seo-title: MicroProfile 3.0 with improved developer experience on Open Liberty 19.0.0.7 - OpenLiberty.io.
seo-description: MicroProfile 3.0 provides improvements to the developer experience of the Rest Client, Health Check, and Metrics features. Open Liberty also now supports the PostgreSQL relational database.
blog_description: "MicroProfile 3.0 provides improvements to the developer experience of the Rest Client, Health Check, and Metrics features. Open Liberty also now supports the PostgreSQL relational database."
---
= MicroProfile Context Propogation on Open Liberty 19.0.0.8
Yasmin Aumeeruddy <https://github.com/yasmin-aumeeruddy>

 TO DOOOOOO!!!!!!
 
 Give it a try in link:/about/[Open Liberty] 19.0.0.8.

In Open Liberty 19.0.0.8:



* <<mcp1,MicroProfile Context Propagation 1.0>>
* <<ocs,OpenID Connect Server>>
* <<int, IBM Open Liberty Introspection>>
** <<over, The Overlay Cache Introspector>>
** <<zip, The zip Cache Introspector>>

If you're curious about what's coming in future Open Liberty releases, take a look at our <<previews,previews in the latest development builds>>. In particular, get an early insight into MicroProfile Reactive Messaging.

== Run your apps using 19.0.0.8

If you're using link:/guides/maven-intro.html[Maven], here are the coordinates:

[source,xml]
----
<dependency>
    <groupId>io.openliberty</groupId>
    <artifactId>openliberty-runtime</artifactId>
    <version>19.0.0.8</version>
    <type>zip</type>
</dependency>
----

Or for link:/guides/gradle-intro.html[Gradle]:

[source,gradle]
----
dependencies {
    libertyRuntime group: 'io.openliberty', name: 'openliberty-runtime', version: '[19.0.0.8,)'
}
----

Or if you're using Docker:

[source]
----
docker pull open-liberty
----

Or take a look at our link:/downloads/[Downloads page].

[link=https://stackoverflow.com/tags/open-liberty]
image::/img/blog/blog_btn_stack.svg[Ask a question on Stack Overflow, align="center"]


[#mcp1]
== MicroProfile Context Propagation 1.0

MicroProfile Context Propagation allows you to create pipelines of dependent stages that run with predictable thread context regardless of which thread the completion stage action ends up running on.

MicroProfile Context Propagation provides completion stages that run with predictable thread context and also benefit from being backed by the link:https://openliberty.io/blog/2019/04/03/liberty-threadpool-autotuning.html[automatically-tuned Liberty global thread pool]. Configuration of concurrency constraints and context propagation is possible programmatically with a fluent builder pattern where configuration defaults can be specified via MicroProfile Config.

Example in `server.xml`:
[source,xml]
----
  <featureManager>
    <feature>mpContextPropagation-1.0</feature>
    <feature>cdi-2.0</feature> <!-- used in example -->
    <feature>jndi-1.0</feature> <!-- used in example -->
    ... other features
  </featureManager>
----

Example usable of programmatic builders:
[source,java]

----
import org.eclipse.microprofile.context.ManagedExecutor;
import org.eclipse.microprofile.context.ThreadContext;
...

ManagedExecutor executor = ManagedExecutor.builder()
    .maxAsync(5)
    .propagated(ThreadContext.APPLICATION, ThreadContext.SECURITY)
    .build();

CompletableFuture<Integer> stage1 = executor.newIncompleteFuture();
stage1.thenApply(function1).thenAccept(value -> {
    try {
        // access resource reference in application's java:comp namespace,
        DataSource ds = InitialContext.doLookup("java:comp/env/jdbc/ds1");
        ...
    } catch (Exception x) {
        throw new CompletionException(x);
    }
};
...
stage1.complete(result);

...
// Shut down managed executor once the application no longer needs it
executor.shutdown();

----

Example usage in a CDI bean:
[source,java]
----
// CDI qualifier which is used to identify the executor instance
@Qualifier
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })
public @interface AppContext {}

// Example producer field, defined in a CDI bean,
@Produces @ApplicationScoped @AppContext
ManagedExecutor appContextExecutor = ManagedExecutor.builder()
    .propagated(ThreadContext.APPLICATION)
    .build();

// Example disposer method, also defined in the CDI bean,
void disposeExecutor(@Disposes @AppContext exec) {
    exec.shutdownNow();
}

// Example injection point, defined in a CDI bean,
@Inject @AppContext
ManagedExecutor executor;

...

CompletableFuture<Integer> stage = executor
    .supplyAsync(supplier1)
    .thenApply(function1)
    .thenApplyAsync(value -> {
        try {
            // access resource reference in application's java:comp namespace,
            DataSource ds = InitialContext.doLookup("java:comp/env/jdbc/ds1");
            ...
            return result;
        } catch (Exception x) {
            throw new CompletionException(x);
        }
    });
----
For more information:

* link:https://openliberty.io/docs/ref/microprofile/3.0/#package=org/eclipse/microprofile/context/package-frame.html&class=org/eclipse/microprofile/context/package-summary.html[JavaDoc API]
* link:https://github.com/eclipse/microprofile-context-propagation/releases/tag/1.0[Spec binaries and Maven coordinates]
* https://github.com/eclipse/microprofile-context-propagation/releases[Context Propagation 1.0 specification]

[#ocs]
== OpenID Connect Server

OpenID Connect is a technology that allows delegation of user authentication to an external security provider.

Liberty's OpenID Connect Server feature now includes support for long-lived application passwords and application tokens, for use by non browser applications. Users can acquire these and submit them to a non-browser application, which can then use them to access secured resources on servers configured to accept OAuth access tokens from the OpenID Connect server. The user's password is never exposed to the non-browser app, and the tokens can be revoked independently if needed. App-passwords are exchanged repetitively by the non-browser app for short lived access tokens using a standard OAuth ROPC flow, so if an access token is ever compromised, it is not valid for long. App-tokens are long-lived access tokens.

Web and REST interfaces for users and administrators are added to administer these tokens.

Create a new Liberty server and use this `server.xml`. Comments in `server.xml` explain the new configuration attributes. This server doesn't have a backing database so is for demo purposes only.

Example in xml: 
[source,xml]
----
<server>
    <featureManager>      
      <feature>openidConnectServer-1.0</feature>     
    </featureManager>

    <openidConnectProvider id="OP" oauthProviderRef="OAuth" 
        signatureAlgorithm="RS256" keyStoreRef="defaultKeyStore" 
        jwkEnabled="true"
    >
    </openidConnectProvider>
    
    <!-- internalClientID and internalClientSecret match a defined 
         client and are used in creating app-passwords and app-tokens.
         passwordGrantRequiresAppPassword enables the ROPC flow to 
         exchange app-passwords for short-lived access tokens.
         appPasswordLifetime and appTokenLifetime set the lifetime of these tokens.
    --> 
    <oauthProvider id="OAuth" tokenFormat="mpjwt" 
      passwordGrantRequiresAppPassword="true" 
      internalClientId="RP" 
      internalClientSecret="thesecret" 
      appPasswordLifetime="30d"
      >
        <!-- 
         localStore for demo use, a backing database is used instead in production. 
         When localStore is used, all client data and token status is held
         in memory only. 
        --> 
        <localStore>
         
          <!-- appPasswordAllowed and appTokenAllowed allow 
          this client to create app-passwords and app-tokens -->
          <client displayname="RP" enabled="true"
                name="RP" secret="thesecret" 
                scope="openid profile email"
                preAuthorizedScope="openid profile email"
                appPasswordAllowed="true"
                appTokenAllowed="true"
          >                  
                <redirect>https://localhost:19443/oidcclient/redirect/RP</redirect>
          </client>    
        </localStore>
    </oauthProvider>
     
    <oauth-roles>
        <authenticated>
            <special-subject type="ALL_AUTHENTICATED_USERS" />  
        </authenticated> 
         <tokenManager>
           <!-- this user can manage the app-passwords and tokens of other users -->
            <user name="admin" />
        </tokenManager> 
    </oauth-roles>

    <!-- Basic registry for test / development use. -->   
    <basicRegistry id="basic" realm="customRealm">
        <user          
          name="admin"
          password="adminpwd" />
        <user
          name="demouser2"
          password="demopassword2" />
         <group name="users">
             <member name="admin"/>
             <member name="demouser2" />
        </group>
    </basicRegistry>

    <httpEndpoint id="defaultHttpEndpoint" host="*" httpPort="29080" httpsPort="29443" />
    <keyStore id="defaultKeyStore" password="keyspass" />  

</server>
----


Now users can request and manage their own tokens at
`pass:[]https://host:port/(provider id)/personalTokenManagement`. Token admins can administer the tokens of other users at `pass:[]https://host:port/(provider id)/usersTokenManagement.`

To try it out, start the server and log in as `admin`, `adminpwd` at
`pass:[]https://localhost:29443/oidc/endpoint/OP/personalTokenManagement`

These tokens can be submitted to non-browser applications, which can in turn use them when accessing secured resources on servers configured to accept access tokens from the OpenID Connect server.

[#int]
== Open Liberty Introspection
 
When diagnosing problems with a server, the link:https://openliberty.io/docs/ref/command/#server-dump.html[server dump] command can be run to obtain information about server configuration, log information, and deployed applications. The command generates a zip archive and Open Liberty 19.0.0.8 introduces two new introspectors to display the data of active root containers on an Open Liberty server process.

Although the `server dump` command can run on servers that have been stopped or are running, introspector output is produced as a step of running a `server dump` on a running server only. 

[#over]
=== Overlay Cache Introspector

The new overlay cache introspector is used to display the active root containers and to display the particular data which has been associated with each container. The viewing archive activity is useful for these purposes:

1. To see what root containers are active within the Open Liberty process.
2. To see the on-disk locations of each of the containers.
3. To obtain a better understanding of typical data which is generated by Open Liberty when starting an application module.

Open Liberty manages application content by creating an overlay container for each of the root locations of the application.  An overlay cache is associated with each of the root containers.

The associated overlay cache is a two layer dictionary. Keys for the first tier are relative paths while keys for the second tier are type names. The overlay cache is used as a mechanism to simplify sharing application related data within the Liberty Application Server.  Sharing a single overlay container replaces sharing many different data items.

The overlay container introspector output is written to the standard server dump archive as entry to `OverlayContainerIntrospector.txt`. To create the output, use the following commands:

Start the server:
[source]
----
server start <serverName>
----
When the server has started, create the dump file:
[source]
----
server dump <serverName>
----

Each use of the `server dump` command creates a server dump ZIP file which has a name based on the server name and which includes a timestamp in the name.

The overlay cache introspector output has three sections.

1. Title and timestamp
+
The descripton of the introspector and overlay container diagnostics are displayed.
+
2. Listing of overlay containers
+
The currently active overlay containers and two containers for each of them, both displayed with a list of URL's. The two containers and referred to as "Base" and "File" which provide the main and additional storage for the overlay container respectively. 
+
3. Cache Data for each overlay container 
+
The list of active overlay containers and the contents of their overlay cache is displayed. 
+


[#zip]
=== Zip Cache Introspector

The new zip cache introspector is used primarily to obtain a view of archive activity within an Open Liberty server process which is useful for a number of purposes:

1. To understand the basic flow of archive file activity within a Liberty server.
2. To detect exceptional archive activity, for example, a pattern of frequent opens and closes of archives, or, when an extremely large number of archives are being opened.
3. To tell if application archives are held open by the Open Liberty process.  This is useful for cases where dynamic updates to application files are blocked because the files are locked.
4. To verify the health of the zip cache layer.  For example, to make sure the zip reaper thread (see below) is running and has been closing zip files at scheduled times.
5. To diagnose the effectiveness of particular zip cache settings.

Introspector output is written to the standard server dump archive as entry to `ZipCachingIntrospector.txt`.

Use the following commands to create the output:
Start the server:
[source]
----
server start <serverName>
----
When the server has started, create the dump file:
[source]
----
server dump <serverName>
----
Each use of the `server dump` command creates a `server dump` ZIP file which has a name based on the server name and timestamp.

The zip cache introspector output contains the following five sections:

1. Title and time stamp
+
The introspector description is displayed with the time and date that the output was created.
+
2. List of properties used to configure the zip caching layer
+
These properties are configuarable as JVM options and in most cases, should be set to their default values.
+
3. List of active and recently used zip file handles
+
The key value for the zip file handles is the full absolute path to an archive file. Information about the cached entries is displayed for each of the file handles.
+
4. Top level state of the zip file cache layer
+
The main function of the cache layer is to delay closing zip files so re-opening zip files that have recently been opened is prevented. The reaper is the thread which eventually closes the zip files and the top level state shows whether the reaper is active, shows the initial, final, and current times of the reaper and includes information about the two threads used by the reaper.
+
5. Data for all managed zip files
+
This data is displayed in four listings: all active and pending zip files, pending zip files which have a short expiration, pending zip files which have a long expiration and lastly, zip files which were recently closed but which have not yet been removed from the cache.
+
