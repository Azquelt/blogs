---
layout: post
title: "OpenLiberty: From JavaEE to Cloud-native in a smooth way"
categories: blog
author_picture: https://avatars1.githubusercontent.com/u/17588715?s=400&u=f8184d1b39015a4f3384e0b49a3fce66222d2866&v=4
seo-title: OpenLiberty: From JavaEE to Cloud-native in a smooth way 
seo-description: Developing apps for the cloud requires new features. OpenLiberty and MicroProfile provides you with features. This blogs shows how to migrate from JavaEE to MicroProfile using OpenLiberty.
blog_description: Developing apps for the cloud requires new features. OpenLiberty and MicroProfile provides you with features. This blogs shows how to migrate from JavaEE to MicroProfile using OpenLiberty.
---
= OpenLiberty: From JavaEE to Cloud-native in a smooth way
Michael Frembs <https://github.com/mfrembs>

Michael is https://www.linkedin.com/in/michael-frembs/[Teamlead Cloud native and Senior Consultant at ARS Computer & Consulting]

First of all: This blog post is not about splitting monoliths into microservices, domain driven design, event storming or something similar. This post is about the technical possibilities provided by OpenLiberty and why I'm very confident that you can go very smoothly from a JavaEE application to a Cloud-native one. I'm a senior consultant for cloud-native topics and have worked in old fashioned JavaEE applications with servers like IBM's WebSphere Application Server (WAS) or RedHat's JBoss EAP. I advise companies to reach cloud technologies and to pick the right tools for their environment.

As a first step it is always a good idea to get rid of cumbersome traditional application servers. They are stable, high performance environments, but they need a lot of time to start and are hard to configure. If you are using the traditional WAS it is recommended to move to OpenLiberty (or WebSphere Liberty Profile a.k.a. WLP). With some limitations (e.g. remote EJBs) it should be possible to easily run your app on WLP without major adjustments. In fact: Some of our clients are still using WAS. As developers, we use WLP to build our apps locally, while in other environments, we use the client's setup.

image::img/blog/blog_mfrembs_microprofile.png[]

WLP provides you with the possibility to add features from JavaEE / JakartaEE side by side to MicroProfile. So you can add some new flavors to your application easily. The image illustrates the MicroProfile. Blue are good known features from JavaEE. Green features will be discussed in this blog. White are further MicroProfile features worth looking into. When you create microservices those microservices communicate with each other. Sometimes you have to use synchronouos RESTful calls. In this situation it is very recommended to use resilience. If you won't do this a broken application can break every app in your calling chain, especially when the response times are long. With MicroProfile you can add resilience to your infrastructure. You can define https://openliberty.io/guides/retry-timeout.html[timeouts] in your (REST-) client or use patterns like the https://openliberty.io/guides/circuit-breaker.html[circuitbreaker] with just an annotation. If you disagree and say that these are within the responsibility of a service mesh: You're right. But sometimes you have not yet a service mesh installed to your infrastructure. When the service mesh is finally installed I've got also good news yor you: https://www.eclipse.org/community/eclipse_newsletter/2018/september/MicroProfile_istio.php[OpenLiberty integrates well with Istio] and recognizes the configurations from the mesh. If there are configurations on both the app and the service mesh the service mesh will overrule. But the service mesh cannot provide the https://github.com/OpenLiberty/guide-microprofile-fallback[fallback] as you'd need business logic to react to errors, with solutions (fallbacks) such as caching, returning default values, throwing errors with descriptive error messages etc..

If you want to develop a cloud-native application it is a good idea to look into the https://12factor.net/[12 factors] app paradigm, which provides guidlines on how to build a "Software as a Service" application. Emily already gave a good https://openliberty.io/blog/2019/09/05/12-factor-microprofile-kubernetes.html[overview]. It is important that you prepare your application for cloud platforms and their requirements. "Lift and Shift" is an anti-pattern. It only means that you run your application on a different "VM" but it's hard - if not impossible - to benefit from the advantages like elastic scaling, self-healing or zero-downtime-deployments. A better approach would be using the https://martinfowler.com/bliki/StranglerFigApplication.html[strangler pattern].

MicroProfile provides you with features you really should look into while developing cloud-native apps. Features like https://openliberty.io/guides/microprofile-metrics.html[Metrics]. When you have multiple, maybe hundreds or thousands of apps running simultaneously, you have to monitor them. Metrics will help you out. The applications provide monitoring systems like prometheus (and grafana for the UI) with information you can analyse and add alerts to it. Metrics like RAM / CPU usage or number of restarts will probably be provided by the cloud platform (Kubernetes does). Furthermore you can create business driven metrics like "how many orders are placed in my shop" or "how many logins are made in which time" and so on. Be creative! You get new possibilities with this feature.

Another important topic is tracing. When you create a microservice infrastructure, you will end up managing services communicating synchronously and asynchronously. Either way it is important to be able to follow the path the communication went, especially while analysing bugs. Imagine you have to find the bug in a calling chain containing 10 apps. Maybe the 10 apps are implemented by different teams. This will be very hard with no further support. You can handle this by passing a trace-id to the message and sending this informations to services like jaeger or zipkin. MicroProfile supports you with an https://github.com/OpenLiberty/guide-microprofile-opentracing[OpenTracing implementation].

Last but not least PaaS cloud platforms like Kubernetes offer https://github.com/OpenLiberty/guide-microprofile-health[self-healing]. Kubernetes knows when your application is in an unstable state and reboots your app for you. This is called "liveness-probe". A "readiness-probe" on the other hand is done while starting your app. When your app is ready it will be added to the load balancer and traffic will be sent to the app. You can help Kubernetes by providing endpoints with information about your app's state. Kubernetes defines a pod as ready when the container is startet - not when the server with the app is startet and ready.

Overall, OpenLiberty is a good choice to stepwise conversion of your JavaEE applications to the cloud-native paradigm. You can add one feature at a time while you refactor your app to comply with the aforementioned 12 factors and get rid of older technologies like EJBs.